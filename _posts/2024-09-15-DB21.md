---
layout: post
author: "Yan"
catalog: true
subtitle: "낙관적 락, 비관적 락 등"
header-img: "img/header/sql.jpg"
title: "Concurrency 제어 - Locking"
date: 2024-09-15 11:40:08 +0000
categories:
  - SQL
tags:
  - SQL
  - DB
comments: true
---

# 동시성 제어와 락 메커니즘

## Concurrency control이란?

다중 사용자 환경을 지원하는 데이터베이스 시스템에서 동시에 실행되는 여러 트랜잭션 간의 간섭으로 문제가 발생하지 않도록 트랜잭션 실행 순서를 제어하는 기법

## 비관적 락 vs 낙관적 락 

### 비관적 락

데이터에 접근할 때마다 락을 걸어 다른 트랜잭션이 접근하지 못하게 하는 방식이다. 데이터 충돌을 미리 방지하기 위해 사용된다.

예시) SELECT FOR UPDATE

```SQL
BEGIN TRANSACTION;
SELECT * FROM orders WHERE order_id = 1 FOR UPDATE;
COMMIT;
```

특정 주문(order_id = 1)에 대해 업데이트를 수행하기 전에 락을 걸어 다른 트랜잭션이 접근하지 못하게 한다.

### 낙관적 락

데이터 변경 시점에만 충돌을 검사하는 방식이다. 낙관적 락은 데이터 충돌이 자주 발생하지 않는 상황에서 성능을 최적화하기 위해 사용된다.  

주로 DB가 아니라 애플리케이션 레벨에서 사용되며, 데이터 변경 시점에 버전 번호를 비교하여 충돌을 검사한다.

트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다.

예시) 주문 객체의 버전번호 비교하여 충돌 검사

```java
public void updateOrder(Order order) {
    Order existingOrder = orderRepository.findById(order.getId());
    if (existingOrder.getVersion() != order.getVersion()) {
        throw new OptimisticLockException("Order has been updated by another transaction");
    }
    order.setVersion(order.getVersion() + 1);
    orderRepository.save(order);
}
```

#### 비관적 락과 낙관적 락의 비교

| 분류   |      비관적 락     |  낙관적 락 |
|:----------:|-------------|------|
| 장점 |  데이터 충돌을 미리 방지할 수 있다   |락을 걸고 있는 동안 다른 트랜잭션이 대기해야 하므로 성능 저하가 발생할 수 있다 |
| 단점  | 데이터 충돌이 자주 발생하지 않는 상황에서 성능을 최적화할 수 있다 |    충돌이 발생할 경우 예외 처리가 필요하다 |


## 구현방법

### 낙관적 락

#### JPA @Version 어노테이션

**@Version**: 버전 관리용 필드를 추가해 트랜잭션 내에서 처음 조회되었을 때의 버전과 수정 후 커밋될 때의 버전을 비교한다. 해당 어노테이션이 붙은 컬럼이 업데이트 될 대 값을 1씩 더해서 저장한다.

- 처음 조회될 때의 버전과 commit될 때의 버전이 서로 다르면 충돌이 발생한 것으로 판단하고 예외를 발생시키다.
- Spring 기반의 JPA에서 낙관적락을 사용하게 되면 충돌시 Hibernate에서 `StaleStateException` 을 발생시킨다. 
- 그리고 Spring에서 이 에외를 `OptimisticLockingFailureException` 로 감싸서 응답하여, 충돌이 발생했는지 알 수 있다.

예시) 

```java
@Entity
public class Student {

    @Id
    private Long id;

    private String name;

    private String lastName;

    @Version
    private Integer version;

    // getters and setters

}
```

- version 어노테이션을 사용하는 엔티티의 필드는 오직 1개여야만 한다.
- primary table이어야 한다.
- 어노테이션을 사용할 수 있는 필드는 int, Integer, long, Long, short, Short, Timestamp 중 하나여야 한다.

##### 낙관적 읽기 & 낙관적 쓰기

- 낙관적 READ : OPTIMISTIC - 잠금 모드를 요청할 때마다 entityManager는 dirty read 뿐만 아니라 unrepeatable read도 방지한다.
- 낙관적 WRITE : OPTIMISTIC INCREMENT - 버전 속성 값을 증가시킨다.

###### reference

> [Optimistic Locking in JPA](https://www.baeldung.com/jpa-optimistic-locking)
> [낙관적 락 테스트하기](https://donghyeon.dev/junit/2021/10/17/%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EA%B8%B0/)


