---
layout: post
author: "Yan"
catalog: true
subtitle: "Security & JWT"
header-img: "img/header/spring.jpg"
title: "Spring - Security"
date: 2022-08-01 11:40:08 +0000
categories:
  - Spring
tags:
  - Spring
  - JWT
  - java
comments: true
---

# 스프링 시큐리티 (Spring Security)
- 스프링 시큐리티란 어플리케이션의 보안(인증 및 인가)을 담당하는 프레임 워크
- 서블릿 필터와 이들로 구성된 필터체인으로 구성된 위임 모델을 사용한다.
- 보안 관련해서 많은 옵션을 제공해주어 개발자가 일일이 보안 관련 로직을 작성하지 않아도 된다는 장점이 있다.
- Spring Security를 사용하지 않으면 자체적으로 세션을 사용하여 체크하던가 기타 다른 방법으로 체크를 해주어야 한다.

### 장점
- 보안과 관련하여 체계적으로 많은 옵션을 제공하여 편리하게 사용할 수 있음
- Filter 기반으로 동작하여 MVC와 분리하여 관리 및 동작 
- 어노테이션을 통한 간단한 설정
- Spring Security는 기본적으로 세션 & 쿠키방식으로 인증

### 인증과 인가
- 인증`Authentication`: 해당 사용자가 본인이 맞는지를 확인하는 절차
- 인가`Authorization`: 인증된 사용자가 요청한 자원에 접근 가능한지를 결정하는 절차
- Spring Security는 기본적으로 인증 절차를 거친 후에 인가 절차를 진행하게 된다.
- 인가 과정에서 해당 리소스에 대한 접근 권한이 있는지 확인한다.
- Spring Security에서는 이러한 인증과 인가를 위해 Principal을 아이디로, Credential을 비밀번호로 사용하는 Credential 기반의 인증 방식을 사용한다. 

### Spring Security 적용시 필수 구현

- Spring Security Dependency
- Spring Security Config
- UserDetailsService 상속
- loadUserByUsername
- CSRF Token Header

## Spring Security의 구조
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99A7223C5B6B29F003)

spring security는 세션-쿠키방식으로 인증  

1. 유저가 로그인을 시도 (http request)
2. AuthenticationFilter 에서부터 위와같이 user DB까지 타고 들어감
3. DB에 있는 유저라면 UserDetails 로 꺼내서 유저의 session 생성
4. spring security의 인메모리 세션저장소인 SecurityContextHolder에 저장
5. 유저에게 session ID와 함께 응답을 내려줌
6. 이후 요청에서는 요청쿠키에서 JSESSIONID를 까봐서 검증 후 유효하면 Authentication를 쥐어준다.

# JWT

- RFC 7519 웹 표준으로 지정되어 있다.
- JSON 객체를 사용해서 토큰 자체에 정보를 저장하고 있는 Web Token이다.
- 헤비하지 않게 사용 가능하다.
- Cookie & Session은 서버의 어떠한 저장소에 해당 값과 매칭되는 value를 가지고 있어야 한다. 그래서 서버 자원이 많이 사용되는 단점이 있다.
- JWT는 Cookie & Session의 자원 문제를 해결하기 위한 방법이다. JWT는 토큰 자체에 유저 정보를 담아서 암호화한 토큰이라고 생각하면 된다. 암호화된 내용은 디코딩 과정을 통해서 해석이 가능하다.

## JWT의 구성
![](https://velog.velcdn.com/images%2Fjkijki12%2Fpost%2Ff0b2592b-c9ad-4529-872f-2575724810e3%2Fimage.png)
- **Header** : Signature를 해싱하기 위한 알고리즘 정보가 담겨 있다. `Header`, `Payload`, `Verify Signature`를 암호화할 방식(Application Layer Gateway)과 타입 포함.
- **Payload** : 서버와 클라이언트가 주고 받는 시스템에서 실제로 사용될 정보를 담고 있다. user의 id, 유효기간 포함.
- **Signature** : 토큰의 유효성 검증을 위한 문자열. 이 문자열을 통해 서버에서는 이 토큰이 유효한 토큰인지 검증할 수 있다. Base64 방식으로 인코딩한 `Header`, `Payload`, `Secret Key`를 더한 값. 

### JWT를 통한 인증절차
1. 사용자가 로그인을 한다.
2. 서버에서는 계정 정보를 읽어 사용자 확인 후, 사용자의 고유ID값을 부여하고 기타 정보와 함께 `Payload`에 집어넣는다.
3. JWT 토큰의 유효기간을 설정한다.
4. 암호화할 Secret key를 이용해 `Access Token`을 발급한다.
5. 사용자는 `Access Token`을 받아 저장 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보낸다.
6. 서버에서는 해당 토큰의 `Verify Signature`를 secret key로 복호화한 후, 조작여부, 유효기간을 확인한다.
7. 검증이 완료되었을 경우 `Payload`를 디코딩하여 사용자의 ID에 맞는 데이터를 가져온다.

> JWT는 보통 Access Token의 유효기간은 매우 짧다. 이유는 보안 문제 때문이다. 그래서 Refresh Token을 따로 발급해주는데, Access Token이 만료되면 새로운 JWT를 발급할 수 있는 토큰이다.

#### JWT의 장점
- 중앙의 인증서버, 데이터 스토어에 대한 의존성이 없다.
- 시스템 수평적 확장에 유리하다.
- Base64 URL Safe Encoding > URL, Cookie, Header 모두 사용이 가능하다.
  - `Base64`란? 8비트 이진 데이터(실행파일, zip파일 등)를 문자 코드에 영향을 받지 않는 공통 ASCII영역의 문자들로만 이루어진 문자열로 바꾸는 인코딩 방식.  ASCII 문자 하나가 64진법의 숫자 하나를 의미하기 때문에 BASE64라는 이름을 가졌다.

#### JWT의 단점
- Payload의 정보가 많아지면 네트워크 사용량이 증가한다. 
- 데이터 설계를 고려할 필요가 있다.
- 토큰이 클라이언트에 저장된다. 서버에서 클라이언트의 토큰을 조작할 수 없다.

# Spring Security와 JWT를 함께 사용하기

##### 1. Spring security와 jwt관련 라이브러리를 build.gradle에 추가
##### 2. security와 filter 관련 설정 하기

```java
@RequiredArgsConstructor
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    private final JwtTokenProvider jwtTokenProvider;

    // authenticationManager를 Bean 등록합니다.
    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {

        http.csrf().disable();
        //http.httpBasic().disable(); // 일반적인 루트가 아닌 다른 방식으로 요청시 거절, header에 id, pw가 아닌 token(jwt)을 달고 간다. 그래서 basic이 아닌 bearer를 사용
        http.httpBasic().disable()
                .authorizeRequests()// 요청에 대한 사용권한 체크
                .antMatchers("/test").authenticated()
                .antMatchers("/admin/**").hasRole("ADMIN")
                .antMatchers("/user/**").hasRole("USER")
                .antMatchers("/**").permitAll()
                .and()
                .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider),
                        UsernamePasswordAuthenticationFilter.class); // JwtAuthenticationFilter를 UsernamePasswordAuthenticationFilter 전에 넣는다
        // + 토큰에 저장된 유저정보를 활용하여야 하기 때문에 CustomUserDetailService 클래스를 생성
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);


    }
}
```
(1) `AuthenticationManager`를 Bean으로 등록해준다.  
(2) 설정해야 할 목록  
- `antMatchers()` : 해당 URL로 요청 시 설정을 해준다.
- `authenticated()` : `andMatchers`에 속해있는 URL로 요청이 오면 인증이 필요하다고 설정한다.
- `hasRole()` : `andMatchers`에 속해있는 URL로 요청이 들어오면 권한을 확인한다.  
(3) `addFilterBefore()` : 필터를 등록한다. 스프링 시큐리티 필터링에 등록해주어야 하기 때문에, 여기에 등록해주어야 한다. 파라미터는 2가지가 들어간다. 왼쪽은 커스텀한 필터링이 들어간다. 오른쪽에 등록한 필터전에 커스텀필터링이 수행된다.  
(4) `http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)` : 세션을 사용하지 않는다고 설정한다.  

##### 3. Custom Filter 구현하기
```java
//해당 클래스는 JwtTokenProvider가 검증을 끝낸 Jwt로부터 유저 정보를 조회해와서 UserPasswordAuthenticationFilter 로 전달
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends GenericFilterBean {

    private final JwtTokenProvider jwtTokenProvider;

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        // 헤더에서 JWT 를 받아옴
        String token = jwtTokenProvider.resolveToken((HttpServletRequest) request);
        // 유효한 토큰인지 확인합니다.
        if (token != null && jwtTokenProvider.validateToken(token)) {
            // 토큰이 유효하면 토큰으로부터 유저 정보를 받아옴
            Authentication authentication = jwtTokenProvider.getAuthentication(token);
            // SecurityContext 에 Authentication 객체를 저장
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        chain.doFilter(request, response);
    }
}
```

##### 4. Custom Provider 구현하기

###### reference

> [Spring boot - security-jwt 연동과 흐름(feat.AccessToken, RefreshToken)](https://kdg-is.tistory.com/228)  
> [Spirng Security + Jwt 로그인 적용하기](https://velog.io/@jkijki12/Spirng-Security-Jwt-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0)  
> [베이스64](https://ko.wikipedia.org/wiki/%EB%B2%A0%EC%9D%B4%EC%8A%A464#cite_ref-2)  
> [spring security 파헤치기 (구조, 인증과정, 설정, 핸들러 및 암호화 예제, @Secured, @AuthenticationPrincipal, taglib)](https://sjh836.tistory.com/165)
